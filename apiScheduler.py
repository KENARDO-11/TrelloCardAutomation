# This function determines what API calls should be run on a given day, then coordinates the requests
import yaml
from time import sleep
import datetime
import os
import sys
from apiCaller import *
# from apiExtensions import *

# Some global lists and dicts
tasklist_filename = f"{sys.path[0]}{os.sep}tasklist.yml"
tasklist = {}
dict_trello_lists = {}
dict_trello_labels = {}
list_trello_lists = []
list_trello_labels = []

# Globally, the last returned card and checklist's json dicts for reference in further tasks in a given job
last_returned_card = {}
last_returned_checklist = {}

# Globally, a list of checklists and checkitems generated by previous tasks, to be referenced in later tasks in a given job
list_returned_checklists = []
list_returned_check_items = []

# Extend YAML Dumper to drop aliases
class NoAliasDumper(yaml.SafeDumper):
    def ignore_aliases(self, data):
        return True

# Fetch the list of scheduled Tasks and store it as a dict
def fetch_tasklist(filename: str):
    print('Fetching the tasklist...')
    with open(filename) as f:
        stream = f.read()
    tasklist.update(yaml.load(stream, yaml.Loader))
    print('tasklist fetched successfully.\n')

# Analyze the tasklist to determine what tasks need to be performed today, in which order #IN PROGRESS
def parse_task_list():
    print('Parsing the tasklist...')
    
    # Get today's date for use in checking whether a task should be run today
    weekdays = [
        'monday',
        'tuesday',
        'wednesday',
        'thursday',
        'friday',
        'saturday',
        'sunday'
    ]
    today_date = datetime.date.today()
    today = weekdays[datetime.date.weekday(today_date)]
    print(f"Today is {today}.")
    
    task_index = 0
    for key, value in tasklist.items():
        run_days = value.get('Run Days')
        
        if run_days.__contains__(today):
            print(f"\nTask \'{value.get('Name')}\' needs to run today.")
            task_index += 1 
            task_file = f'{sys.path[0]}{os.sep}Tasks{os.sep}'
            task_file += value.get('File')
            print(f"Starting Task {task_index}: {value.get('Name')}")
            read_task(task_file)

            update_task = {key: value}
            update_value = value
            last_run = {'Last Run': today_date.isoformat()}
            update_value.update(last_run)
            # update_task.update(key=update_value)

            print('Updating Task List with last-run date...')
            tasklist.update(update_task)
            update_tasklist()
        
        else:
            print(f"\nTask \'{value.get('Name')}\' does not run on {today}.")

# Fetch the specified Task YAML file, read it, and call the appropriate functions in order #IN PROGRESS
def read_task(filename: str):
    with open(filename) as f:
        stream = f.read()
    read_tasks = yaml.load(stream, yaml.Loader)
    print('\nOpened Task File successfully.')

    if read_tasks is None:
        print("Nothing to do. Skipping.")
        return

    for key, value in read_tasks.items():
        
        # Error Handler tries each task up to 3 times, sleeping for sleep_time seconds if it fails and backing off each time
        sleep_time = 3
        for b in range(3):
            try:
                if key.__contains__('New'):
                    if key.__contains__('Card'):
                        create_card(value)
                    elif key.__contains__('Checklist'):
                        create_checklist(value)
                    elif key.__contains__('CheckItem'):
                        create_check_item(value)
                    else:
                        print(f"Something went wrong. {key} is  not a valid request type.")

                elif key.__contains__('Update'):
                    if key.__contains__('Card'):
                        update_card(value)
                    elif key.__contains__('Checklist'):
                        update_checklist(value)
                    elif key.__contains__('CheckItem'):
                        update_check_item(value)
                    else:
                        print(f"Something went wrong. {key} is  not a valid request type.")
                
                else:
                    print(f"Something went wrong. {key} is not a valid request type.")
                errored = None

            except Exception as errored:
                except_msg = str(errored).replace(API_KEY, "API Key Hidden-")
                except_msg = except_msg.replace(API_TOKEN, "API Token Hidden-")
                pass

            try: 
                errored
                break
            except NameError:
                print(f"{except_msg}\n Sleeping for {sleep_time} seconds before trying again...")
                sleep(sleep_time)
                sleep_time *= 2
            b += 1

    # Clear the lists of returned items at the end of each task, before the next task starts.
    list_returned_checklists.clear()
    list_returned_check_items.clear()

# Update tasklist.yml whenever a task completes
def update_tasklist():
    stream = open(tasklist_filename, mode='w+')
    yaml.dump(data=tasklist, stream=stream, Dumper=NoAliasDumper, explicit_start=True)
    return

# Get the information on Lists
def read_lists():
    print('\nReading Lists...')
    list_trello_lists.clear()
    list_trello_lists.extend(get_list_ids())
    
    for i in range(len(list_trello_lists)):
        temp_dict = {list_trello_lists[i].get('name'): i}
        dict_trello_lists.update(temp_dict)
        i += 1
    
    return dict_trello_lists, list_trello_lists

# Get the information on Labels
def read_labels():
    print('\nReading Labels...')
    list_trello_labels.clear()
    list_trello_labels.extend(get_label_ids())

    for i in range(len(list_trello_labels)):
        temp_dict = {list_trello_labels[i].get('name'): i}
        dict_trello_labels.update(temp_dict)
        i += 1
    
    return dict_trello_labels, list_trello_labels

# Get the {option}s for the "Epic" CustomField
def getepic_options():
    print('\nGetting a list of options for the Epic field...')
    # Make sure get_custom_fields() has been run at least once
    list_custom_fields = get_custom_fields()

    # Iterate through list_custom_fields[] to find the 'Epic' field, and set it as epic_field
    for i in range(len(list_custom_fields)):
        if list_custom_fields[i].get('name') == 'Epic':
            print(f"Found Epic at Index {i}")
            epic_field = list_custom_fields[i]
            break
        else:
            epic_field = None
        i += 1          

    epic_options = epic_field.get('options')
    # Iterate through epic_field[] and add each 'id' and 'value' to list_epic_optionsn[]
    list_epic_optionsn = []
    for b in range(len(epic_options)):
        temp_dict = {'id': epic_options[b].get('id'), 'value': epic_options[b].get('value')}
        list_epic_optionsn.append(temp_dict)
        b += 1

    return list_epic_optionsn

# Build a "Create Card" request and feed it to apiCaller
def create_card(new_card_details: dict):
    print('\nBuilding a new Card...')
    
    # Normalize the request
    normalized_details = normalize_request_detailss(new_card_details)

    # Instantiate local variables and clear last_returned_card{}
    request_details = normalized_details.get('request')
    idList = normalized_details.get('idList')
    idLabels = normalized_details.get('idLabels') 
    nameLabels = request_details.get('nameLabels')
    nameList = request_details.get('nameList')
    list_idLabels = []
    last_returned_card.clear()
    
    # Variables to hold values that can't be set by Create Card and require an implicit update
    idCustomField = request_details.get('idCustomField')
    nameCustomField = request_details.get('nameCustomField')
    valueCustomField = request_details.get('valueCustomField')   
    new_card_cover = normalized_details.get('cover')    
    del normalized_details['request']

    # Transmit the Create Card request
    new_card_json = normalized_details
    new_card_resposne = post_new_card(new_card_json)
    response_msg = new_card_resposne[0]
    returned_card = new_card_resposne[1]
    last_returned_card.update(returned_card)
    
    # Perform implicit updates for card details that can't be added during Create
    if new_card_cover is not None or idCustomField is not None or nameCustomField is not None or valueCustomField is not None:
        new_elements = {
            'idCustomField': idCustomField,
            'nameCustomField': nameCustomField,
            'valueCustomField': valueCustomField,
            'cover': new_card_cover
        }
        implicit_update_card = make_implicit_update_card(returned_card, new_elements)
        update_card(implicit_update_card)

    last_returned_card.update(returned_card)
    return returned_card

# Build an "Update Card" rquest and feed it to apiCaller
def update_card(update_card_details: dict):
    print('\nBuilding an Update Card request...')
    
    # Normalize the request
    normalized_details = normalize_request_detailss(update_card_details)
    if normalized_details is None:
        return
    # Instantiate local variables
    request_details = normalized_details.get('request')
    idCard = request_details.get('idCard') 
    idList = normalized_details.get('idList')
    idLabels = normalized_details.get('idLabels')
    idCustomField = request_details.get('idCustomField')  
    nameCustomField = request_details.get('nameCustomField')
    valueCustomField = request_details.get('valueCustomField')
    job_extensions = normalized_details.get('job_extensions')
    idValue = None

    # Get the Custom Field ID to update if 'idCustomField' is empty but a custom field is named.
    if idCustomField is None:
        if nameCustomField is not None:
            custom_fields = get_custom_fields()
            for i in range(len(custom_fields)):
                if custom_fields[i].get('name') == nameCustomField:
                    idCustomField = custom_fields[i].get('id')
                i += 1

    # Make sure we only try to handle Custom Field values in a valid way
    if valueCustomField is not None:
        if idCustomField is not None:
            custom_field_request = {'idCustomField': '', 'value': ''}
            
            if nameCustomField == 'Epic':
                epic_options = getepic_options()

                for i in range(len(epic_options)):
                    epic_value = epic_options[i].get('value')
                    if epic_value.get('text') == valueCustomField:
                        idValue = epic_options[i].get('id')
                        custom_field_request.update(idValue=idValue)
                        valueCustomField = None
                        break
                    i += 1    
            else:
                valueCustomField = {'text': valueCustomField }

            custom_field_request.update(idCustomField=idCustomField, value=valueCustomField, idValue=idValue)
            update_card_response = put_update_card(custom_field_request, idCard)
        else:
            print("Error: A Custom Field Value was specified without a Custom Field ID or Name")

    # Call Extensions if they're requested
    if job_extensions is not None:
        for i in range(len(job_extensions)):
            extensionCall = job_extensions[i]

            enrichedData = eval(extensionCall)
            normalized_details.update(enrichedData)
            i += 1
        
    # Some cleanup
    del normalized_details['request']
    last_returned_card.clear()
    update_card_json = normalized_details

    # Transmit the Update Card requeest
    update_card_response = put_update_card(update_card_json, idCard)
    response_msg = update_card_response[0]
    returned_card = update_card_response[1]

    last_returned_card.update(returned_card)
    return returned_card

# Build a "Create Checklist" request and feed it to apiCaller
def create_checklist(new_checklist_details: dict):
    print('\nBuilding a new Checklist...')
    # Normalize the request
    normalized_details = normalize_request_detailss(new_checklist_details)   
    idCard = normalized_details.get('idCard')
    last_returned_checklist.clear()

    normalized_details.update(idCard=idCard)
    new_checklist_json = normalized_details
    new_checklist_response = post_new_checklist(new_checklist_json)
    response_msg = new_checklist_response[0]
    returned_checklist = new_checklist_response[1]

    last_returned_checklist.update(returned_checklist)
    list_returned_checklists.append(last_returned_checklist)
    return returned_checklist

# Build a "Create CheckItem" request and feed it to apiCaller
def create_check_item(new_check_item_details: dict):
    print('\nBuilding a new Check Item...')
    check_item_request = new_check_item_details.get('request')
    idChecklist = check_item_request.get('idChecklist')

    if idChecklist is None:
        pass
    elif type(idChecklist) is int:
        idChecklist = last_returned_checklist.get('id')

    del new_check_item_details['request']
    
    new_check_item_json = new_check_item_details
    new_check_item_response = post_new_checkitem(new_check_item_json, idChecklist)
    response_msg = new_check_item_response[0]
    returned_check_item = new_check_item_response[1]

    list_returned_check_items.append(returned_check_item)
    return returned_check_item

# Build an "Update Checklist request and feed it to apiCaller"
def update_checklist(update_checklist_details: dict):
    print("The API Caller does not currently have Update Checklist functionality.")
    pass

# Build an "Update CheckItem" request and feed it to apiCaller
def update_check_item(update_check_item_details: dict):
    print("The API Caller does not currently have Update Checklist Item functionality.")
    pass

# Normalize common requests to use IDs instead of Names
def normalize_request_detailss(irregular_request_details: dict):
    print('Normalizing request parameters...')
    
    normalized_details =  irregular_request_details

    # Get the 'request' dict if it exists, create one with None values otherwise
    if irregular_request_details.get('request') is not None:
        request_details = irregular_request_details.get('request')
    else:
        request_details = {
            'idCard': None,          
            'nameLabels': None,
            'nameList': None,        
            'idCustomField': None,   
            'nameCustomField': None, 
            'valueCustomField': None
        }
    
    # Special handling for idCard, which may appear in 'request' or the body
    if irregular_request_details.get('idCard') is None:
        idCard = request_details.get('idCard')
    else:
        idCard = irregular_request_details.get('idCard')

    idList = irregular_request_details.get('idList')
    idLabels = irregular_request_details.get('idLabels') 
    nameLabels = request_details.get('nameLabels')
    nameList = request_details.get('nameList')
    list_idLabels = []

    # Normalize idList
    if idList is None:
        if nameList is None:
            print('No List specified.')
        else:
            new_index = dict_trello_lists.get(nameList)
            new_list = list_trello_lists[new_index]
            new_list_id = new_list.get('id')
            normalized_details.update(idList=new_list_id)    

    # Normalize idCard
    if idCard is None:
        print('No Card ID provided')
    elif idCard == 'self':
        idCard = last_returned_card.get('id')
        request_details.update(idCard=idCard)
    elif idCard == 'list':
        make_iterative_update_card(irregular_request_details)
        return

    # normalize idLabels
    if idLabels is None:
        if nameLabels is None:
            print('No Labels provided.')    
        else:
            for i in range(len(nameLabels)):
                search_label = nameLabels[i]
                label_index = dict_trello_labels.get(search_label)
                list_idLabels.append(list_trello_labels[label_index].get('id'))
                i += 1
            normalized_details.update(idLabels=list_idLabels)

    normalized_details.update(request_details)
    return normalized_details

# Create a new dict to feed update_card() when the New Card task contains elements that Trello doesn't add on creation
def make_implicit_update_card(card_details: dict, new_elements: dict):
    print('Performing an implicit update...')
    idCard = card_details.get('id')
    idCustomField = new_elements.get('idCustomField')
    nameCustomField = new_elements.get('nameCustomField')
    valueCustomField = new_elements.get('valueCustomField')
    cover = new_elements.get('cover')

    implicit_update_card = {
        'request': {
            'idCard': idCard,
            'idCustomField': idCustomField,
            'nameCustomField': nameCustomField,
            'valueCustomField': valueCustomField,
        },
        'cover': cover
    }

    return implicit_update_card

# Use a list to do generate update_card() calls for each card in the list
def make_iterative_update_card(list_card_detailsl: dict):
    print('Starting an Iterative Update proces...')

    request_details = list_card_detailsl.get('request')
    idList = list_card_detailsl.get('idList')
    nameList = request_details.get('nameList')
    list_idCards = []
    
    list_cards_in_list = get_cards_in_list(idList)
    print(f"Iterating through {len(list_cards_in_list)} cards...")
    #Iterate through the list of cards in the List and make a list of Card IDs
    for i in range(len(list_cards_in_list)):
        temp_idCard = list_cards_in_list[i].get('id')
        list_idCards.append(temp_idCard)
        i += 1
    
    #Iterate through the list of Card IDs and call update_card() for each one
    for i in range(len(list_idCards)):
        print(f"Building request details for Card #{i+1}")
        temp_request = request_details
        temp_request.update(idCard=list_idCards[i], nameList=None)
        temp_update_card = list_card_detailsl
        temp_update_card.update(request=temp_request, idList=idList)

        update_card(temp_update_card)
        i += 1

    return

# Main function
def main():
    fetch_tasklist(tasklist_filename) 
    read_lists()
    read_labels()
    parse_task_list()

if __name__ == '__main__':
    main()